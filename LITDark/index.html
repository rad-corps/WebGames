<!DOCTYPE HTML>
<html>
<head>
	<title>Lit Dark</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #FFF;
		}

		#loader{
    		/*background:green; */
    		width:848px;
    		height:480px;   
    		text-align: center;
		}
	</style>
	<script src="../bin/pixi.js"></script>

</head>
<body>

    <div id="loader" class="layer">
    	<br></br>
        <h3>Loading LIT Dark</h3>
        <img src="./img/loading_transparent.gif" alt="loader" />     
    </div>

	<script>

//hide the URL bar
// When ready...
window.addEventListener("load",function() {
	// Set a timeout...
	setTimeout(function(){
		// Hide the address bar!
		window.scrollTo(0, 1);
	}, 0);
});


//https://github.com/kittykatattack/learningPixi#keyboard
function keyboard(keyCode) {
  var key = {};
  key.code = keyCode;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;
  //The `downHandler`
  key.downHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isUp && key.press) key.press();
      key.isDown = true;
      key.isUp = false;
    }
    event.preventDefault();
  };

  //The `upHandler`
  key.upHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isDown && key.release) key.release();
      key.isDown = false;
      key.isUp = true;
    }
    event.preventDefault();
  };

  //Attach event listeners
  window.addEventListener(
    "keydown", key.downHandler.bind(key), false
  );
  window.addEventListener(
    "keyup", key.upHandler.bind(key), false
  );
  return key;
}


//Keith Peter's Vector JS class
var vector2 = {
	_x: 1,
	_y: 0,

	create: function(x, y) {
		var obj = Object.create(this);
		obj.setX(x);
		obj.setY(y);
		return obj;
	},

	setX: function(value) {
		this._x = value;
	},

	getX: function() {
		return this._x;
	},

	setY: function(value) {
		this._y = value;
	},

	getY: function() {
		return this._y;
	},

	setAngle: function(angle) {
		var length = this.getLength();
		this._x = Math.cos(angle) * length;
		this._y = Math.sin(angle) * length;
	},

	getAngle: function() {
		return Math.atan2(this._y, this._x);
	},

	setLength: function(length) {
		var angle = this.getAngle();
		this._x = Math.cos(angle) * length;
		this._y = Math.sin(angle) * length;
	},

	getLength: function() {
		return Math.sqrt(this._x * this._x + this._y * this._y);
	},

	// add: function(v2) {
	// 	return vector2.create(this._x + v2.getX(), this._y + v2.getY());
	// },

	// subtract: function(v2) {
	// 	return vector2.create(this._x - v2.getX(), this._y - v2.getY());
	// },

	// multiply: function(val) {
	// 	return vector2.create(this._x * val, this._y * val);
	// },

	// divide: function(val) {
	// 	return vector2.create(this._x / val, this._y / val);
	// },

	addTo: function(v2) {
		this._x += v2.getX();
		this._y += v2.getY();
	},

	subtractFrom: function(v2) {
		this._x -= v2.getX();
		this._y -= v2.getY();
	},

	multiplyBy: function(val) {
		this._x *= val;
		this._y *= val;
	},

	divideBy: function(val) {
		this._x /= val;
		this._y /= val;
	},

	normalise: function() {
		var mag = this.getLength();
		this._x /= mag;
		this._y /= mag;	
	},

	toString: function(){
		return 'x: ' + this._x + '\ty: ' + this._y;
	}
};

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//GAME GLOBALS
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
var gameState = 'loading'; //'playing', 'gameOver', 'loading'
var gameLoop = null;
var lastUpdate = Date.now();

var AH_GLOBALS = { 
	SCREEN_W: 848,
	SCREEN_H: 480,
	PLAYER_SPEED: 3,
	WALL_SPEED: 1
};

var fontStyle = {
	align: 'center',
    font : '36px Arial bold italic',
    fill : '#F7EDCA',
    stroke : '#4a1850',
    strokeThickness : 5,
    dropShadow : true,
    dropShadowColor : '#000000',
    dropShadowAngle : Math.PI / 6,
    dropShadowDistance : 6,
    wordWrap : true,
    wordWrapWidth : 440
};

var scoreFontStyle = {
	align: 'center',
    font : '20px Arial bold italic',
    fill : '#F7EDCA',
    stroke : '#4a1850',
    strokeThickness : 1,
    dropShadow : true,
    dropShadowColor : '#000000',
    dropShadowAngle : Math.PI / 6,
    dropShadowDistance : 2,
    wordWrap : true,
    wordWrapWidth : 440
};

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//GAME FUNCTIONS
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

function onAssetsLoaded(){

	window.gameLoop = new GameLoop();
	//window.gameLoop.init();
	window.gameLoop.run();
	startGame();
	document.getElementById("loader").style.display = "none";
}

//LOAD ALL PRELOADED TEXTURES IN HERE
//////////////////////////////////////////////
function preloadTextures() {
	
	// create a new loader
	var loader = PIXI.loader;
	loader.add('player', './img/player.png');
	loader.add('button0', './img/button0.png');
	loader.add('button1', './img/button1.png');
	loader.add('crate', './img/crate.png');
	loader.add('goal', './img/goal.png');
	loader.add('rat', './img/rat.png');
	loader.add('terrain0', './img/terrain0.png');
	loader.add('terrain1', './img/terrain1.png');
	loader.add('wall', './img/wall.png');
	// use callback
	loader.once('complete', onAssetsLoaded);
	//begin load
	loader.load();
}

function startGame() {		
	gameLoop.init();
	gameState = 'playing';
}

function playAgain() {
	startGame();
	window.blackHole.SetPos(new PIXI.Point(AH_GLOBALS.SCREEN_W/2, AH_GLOBALS.SCREEN_H/2));
}

function scaleSprite(sprite_){
	
	//commented out to remove scaling
	// sprite_.scale.x = window.innerHeight / AH_GLOBALS.SCREEN_H;
	// sprite_.scale.y = window.innerHeight / AH_GLOBALS.SCREEN_H;
}

function collisionManager(sprite1, sprite2)
{
	//find left, right, top and bottom of sprite1
	var l1 = sprite1.position.x - sprite1.width /2;
	var r1 = sprite1.position.x + sprite1.width /2;
	var t1 = sprite1.position.y + sprite1.height /2;
	var b1 = sprite1.position.y - sprite1.height /2;
	var l2 = sprite2.position.x - sprite2.width /2;
	var r2 = sprite2.position.x + sprite2.width /2;
	var t2 = sprite2.position.y + sprite2.height /2;
	var b2 = sprite2.position.y - sprite2.height /2;

	if (r1 < l2 || r2 < l1 || b1 > t2 || t1 < b2){
		return false;
	}
	return true;
}

///////////////////////////////////////
///////////////////////////////////////
//////////////////////////////////////
//GAME OBJECTS
/////////////////////////////////////
//////////////////////////////////////
///////////////////////////////////////

//level key
// 0 = terrain0
// 1 = terrain1
// 2 = wall

// 6 = goal

var levelBottom = [
[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,2,2,2,1,0,1,0,2,2,2,2,2,2,1,0,1,0,1,0,1,0,1,0,1],
[1,0,2,0,1,2,1,0,1,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,2,1,0,1,0,1,0,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
[1,0,2,0,1,0,1,0,1,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,2,1,0,2,0,1,0,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
[1,0,2,2,2,0,1,0,1,2,2,2,2,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,2,1,0,1,0,1,0,2,2,2,2,1,0,1,0,1,0,1,0,1,0,1,0,1],
[1,0,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
[1,0,2,0,1,0,1,0,1,2,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,2,1,0,1,0,1,0,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
[0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
];


//0 = nothing
//1 = wall moving down
//2 = wall moving up
//3 = wall moving right/east
//4 = wall moving right/east
//5 = button 
//6 = crate

var levelTop = [
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],
[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,6,6,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,0,6,6,0,0],
[0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,0,0,0,0,0,0,0,0],
[0,0,0,0,0,0,0,0,0,0,0,3,0,0,4,0,0,0,0,0,0,0,0,0,0,0],
];


//takes a 2D array 15x15
function Terrain(level_){

	var self = this;
	
	//iterators
	var row = 0;
	var col = 0;
	
	//temp
	var spriteRow = [];
	var tempTile = undefined;
	var tempSprite = undefined;

	//2D array of sprites based on the level passed in
	this.level = level_;
	this.spriteArray = [];


	this.level = level_;

	for (row = 0; row < level_.length; ++row )
	{		
		//empty spriteRow array
		spriteRow = [];

		for (col = 0; col < level_[row].length; ++col )	
		{
			//add one to the spriteRow
			tempTile = level_[row][col];

			if ( tempTile === 0 )
			{
				tempSprite = PIXI.Sprite.fromImage("./img/terrain0.png");
			}
			else if ( tempTile === 1)
			{
				tempSprite = PIXI.Sprite.fromImage("./img/terrain1.png");
			}
			else if ( tempTile === 2)
			{
				tempSprite = PIXI.Sprite.fromImage("./img/wall.png");
			}

			//set the position of the sprite
			tempSprite.anchor.x = 0.5;
			tempSprite.anchor.y = 0.5;
			tempSprite.position.x = col * 32;
			tempSprite.position.y = row * 32;
			spriteRow.push(tempSprite);			
		}

		this.spriteArray.push(spriteRow);
	}

	//console.log(this.spriteArray);

	this.update = function() { 

	}

	this.getSpriteArray = function(){ 
		return self.spriteArray;
	}

	this.addToStage = function(stage_){
		
		for (var row = 0; row < self.spriteArray.length; row++)
		{
			for (var col = 0; col < self.spriteArray[row].length; col++)
			{
				stage_.addChild(self.spriteArray[row][col]);	
			}
		}		
	}

	this.walkableTerrain = function(row_, col_)
	{
		if ( self.level[row_][col_] === 2 ) { 
			return false;
		}
		return true;
	}

	this.collidesWith = function(playerSprite_)
	{
		for (var row = 0; row < self.spriteArray.length; row++)
		{
			for (var col = 0; col < self.spriteArray[row].length; col++)
			{
				if ( self.walkableTerrain(row, col) === false)
				{
					//check for collision
					if ( collisionManager( playerSprite_, self.spriteArray[row][col]) )
					{

						return true;
					}
				}
			}
		}
		return false;
	}
}

function TopLevelTerrain(level_)
{
	var self = this;
	
	//iterators
	var row = 0;
	var col = 0;
	
	//temp
	var spriteRow = [];
	var tempTile = undefined;
	var tempSprite = undefined;

	//2D array of sprites based on the level passed in
	this.level = level_;
	this.spriteArray = [];

	this.distTraveled = 0;

	this.level = level_;
	this.invertDirection = false;

	for (row = 0; row < level_.length; ++row )
	{		
		//empty spriteRow array
		spriteRow = [];

		for (col = 0; col < level_[row].length; ++col )	
		{
			//add one to the spriteRow
			tempTile = level_[row][col];

			if ( tempTile === 0 )
			{
				tempSprite = undefined;
				//tempSprite = PIXI.Sprite.fromImage("./img/terrain0.png");
			}
			else //none 0
			{
				tempSprite = PIXI.Sprite.fromImage("./img/wall.png");
			}

			if ( tempSprite !== undefined )
			{
				//set the position of the sprite
				tempSprite.anchor.x = 0.5;
				tempSprite.anchor.y = 0.5;
				tempSprite.position.x = col * 32;
				tempSprite.position.y = row * 32;
						
			}
			spriteRow.push(tempSprite);	
		}

		this.spriteArray.push(spriteRow);
	}

	this.addToStage = function(stage_){
		
		for (var row = 0; row < self.spriteArray.length; row++)
		{
			for (var col = 0; col < self.spriteArray[row].length; col++)
			{
				if ( self.spriteArray[row][col] !== undefined )
				{
					stage_.addChild(self.spriteArray[row][col]);	
				}
			}
		}		
	}

	this.walkableTerrain = function(row_, col_)
	{
		if ( self.level[row_][col_] === 0 ) { 
			return true;
		}
		return false;
	}

	this.collidesWith = function(playerSprite_)
	{
		for (var row = 0; row < self.spriteArray.length; row++)
		{
			for (var col = 0; col < self.spriteArray[row].length; col++)
			{
				if ( self.walkableTerrain(row, col) === false)
				{
					//check for collision
					if ( collisionManager( playerSprite_, self.spriteArray[row][col]) )
					{

						console.log("inside wall");
						return true;
					}
				}
			}
		}
		return false;
	}

	this.update = function(dt_)
	{
		var speed = AH_GLOBALS.WALL_SPEED;
		if (self.distTraveled >= 32 )
		{
			self.invertDirection = !self.invertDirection;
			self.distTraveled = 0;
		}
		self.distTraveled += speed;

		//iterate over all tile types		
		for (var row = 0; row < self.level.length; row++)
		{
			for (var col = 0; col < self.level[row].length; col++)
			{
				if ( self.level[row][col] === 1 ) //move down
				{
					if ( self.invertDirection === true)
						self.spriteArray[row][col].position.y -= speed;
					if ( self.invertDirection === false)
						self.spriteArray[row][col].position.y += speed;
					
				}
				else if ( self.level[row][col] === 2 ) //move up
				{
					if ( self.invertDirection === true)
						self.spriteArray[row][col].position.y += speed;
					if ( self.invertDirection === false)
						self.spriteArray[row][col].position.y -= speed;
				}
				else if ( self.level[row][col] === 3 ) //move left
				{
					if ( self.invertDirection === true)
						self.spriteArray[row][col].position.x += speed;
					if ( self.invertDirection === false)
						self.spriteArray[row][col].position.x -= speed;
					
				}
				else if ( self.level[row][col] === 4 ) //move right
				{
					if ( self.invertDirection === true)
						self.spriteArray[row][col].position.x -= speed;
					if ( self.invertDirection === false)
						self.spriteArray[row][col].position.x += speed;
				}
				else if ( self.level[row][col] === 5 ) //zig zag 1
				{
					if ( self.invertDirection === true)
						self.spriteArray[row][col].position.x += speed;
					if ( self.invertDirection === false)
						self.spriteArray[row][col].position.y -= speed;
				}
				else if ( self.level[row][col] === 6 ) //zig zag 2
				{
					if ( self.invertDirection === true)
						self.spriteArray[row][col].position.x -= speed;
					if ( self.invertDirection === false)
						self.spriteArray[row][col].position.y += speed;
				}				

			}
		}
	}

}

function Player(){
	var self = this;

	this.sprite = PIXI.Sprite.fromImage("./img/player.png");
	this.sprite.anchor.x = 0.5;
	this.sprite.anchor.y = 0.5;
	this.sprite.position.set(AH_GLOBALS.SCREEN_W/2, AH_GLOBALS.SCREEN_H/2 - 100);

	this.oldX = 0;
	this.oldY = 0;
	
	this.velocity = vector2.create(0,0);	

	scaleSprite(this.sprite);

	//define keyObjects and listeners
	this.kN = keyboard(38);
	this.kS = keyboard(40);
	this.kE = keyboard(39);
	this.kW = keyboard(37);

	//NORTH
	this.kN.press = function() {
		self.velocity._y -= AH_GLOBALS.PLAYER_SPEED;
	}
	this.kN.release = function() {
		self.velocity._y += AH_GLOBALS.PLAYER_SPEED;
	}
	//SOUTH
	this.kS.press = function() {
		self.velocity._y += AH_GLOBALS.PLAYER_SPEED;
	}
	this.kS.release = function() {
		self.velocity._y -= AH_GLOBALS.PLAYER_SPEED;
	}	
	//EAST
	this.kE.press = function() {
		self.velocity._x += AH_GLOBALS.PLAYER_SPEED;
	}
	this.kE.release = function() {
		self.velocity._x -= AH_GLOBALS.PLAYER_SPEED;
	}	
	//WEST
	this.kW.press = function() {
		self.velocity._x -= AH_GLOBALS.PLAYER_SPEED;
	}
	this.kW.release = function() {
		self.velocity._x += AH_GLOBALS.PLAYER_SPEED;
	}	


	this.update = function()
	{
		if ( gameState === 'playing'){ 

			self.oldX = self.sprite.position.x;
			self.oldY = self.sprite.position.y;

			self.sprite.position.x += this.velocity._x;
			self.sprite.position.y += this.velocity._y;;
			//self.sprite.rotation += 0.04;
		}
	}

	this.undoX = function(){
		self.sprite.position.x = self.oldX;
	}

	this.undoY = function() {
		self.sprite.position.y = self.oldY;
	}

}

function GameLoop(){

	var self = this;
	
	//create the renderer
	this.renderer = new PIXI.WebGLRenderer(AH_GLOBALS.SCREEN_W, AH_GLOBALS.SCREEN_H);//autoDetectRenderer(400, 300);

	//add it to the DOM body
	document.body.appendChild(this.renderer.view);

	//create a stage (all sprites added to this)
	self.stage = new PIXI.Container();

	this.init = function(){
		console.log("init");

		self.player = new Player();
		self.terrain = new Terrain(window.levelBottom);
		self.topTerrain = new TopLevelTerrain(window.levelTop);

		self.promptText = new PIXI.Text('LITDark Click To Play', fontStyle);

		self.promptText.interactive = true;
		self.promptText.on('mousedown', playAgain);	
		self.promptText.on('touchstart', playAgain);	
		self.promptText.position.set(AH_GLOBALS.SCREEN_W/2, AH_GLOBALS.SCREEN_H/2);
		self.promptText.anchor.x = 0.5;
		self.promptText.anchor.y = 0.5;
		
		//self.stage.addChild(this.gameBG.sprite);
		//self.stage.addChild(window.blackHole.sprite);
		self.terrain.addToStage(self.stage);
		self.stage.addChild(this.player.sprite);
		self.topTerrain.addToStage(self.stage);
		//self.stage.addChild(self.timer.promptText);
		//self.stage.removeChild(self.loadingText);


	}

	this.run = function() {
		requestAnimationFrame( this.animate );
	}

	this.animate = function(){

		//calc delta
		var now = Date.now();
		var dt = now - lastUpdate;
		lastUpdate = now;

		if ( gameState === 'playing') {
    		self.player.update();

    		//iterate over terrain. only check collision on the non walkable stuff
			if (self.terrain.collidesWith(self.player.sprite) )
			{
				self.player.undoX();
				self.player.undoY();
			}

			if (self.topTerrain.collidesWith(self.player.sprite) )
			{
				self.player.undoX();
				self.player.undoY();
			}				

			self.topTerrain.update();
    	}
    	if  ( gameState === 'gameOver') {
    		self.stage.addChild(self.promptText);
    		gameState = 'mainMenu';
    	}    	
    	self.renderer.render(self.stage);		
		requestAnimationFrame( self.animate );
	}
}

preloadTextures();

	</script>

	</body>
</html>
